--# Main-- Code 09 Physics Lab Car-- This is a modification of the Physics Lab demo example -- by John Millard that is included with Codea.-- After exploring that example, we want to focus on some-- of the ideas that are presented.-- This keeps the iPad screen from rotatingsupportedOrientations(LANDSCAPE_RIGHT)function setup()        -- This gives lines rounded ends    lineCapMode(ROUND)    -- Create a shortcut to PhysicsDebugDraw    debugDraw = PhysicsDebugDraw()        -- test classes    -- to add your own, make sure to define setup() and cleanup()     -- in addition to draw() and touched()    -- I use two parameters    -- UseAccelerometer lets objects float if true        -- if false gravity is in effect    parameter.boolean("UseAccelerometer")    -- This turns display of contact point display on or off    parameter.boolean("DrawContacts")    Car:setup()        -- Use device gravity instead of our definition    defaultGravity = physics.gravity()end-- This function gets called once every framefunction draw()    -- This sets the background color to black    -- Move this below debugDraw and you can't see the objects   background(0, 0, 0)        debugDraw:draw()        local str = string.format("Test Car - motors (hold on left or right of screen to move car)")     font("MyriadPro-Bold")    fontSize(22)    fill(255, 255, 255, 255)        -- Put a title on the screen    text(str, WIDTH/2, HEIGHT - 20)        -- Turn gravity on or off    if UseAccelerometer == true then        physics.gravity(Gravity)    else        physics.gravity(defaultGravity)    endendfunction touched(touch)                Car:touched(touch)endfunction collide(contact)        -- Controls the contact dots        debugDraw:collide(contact)    end--# PhysicsDebugDraw-- debugDraw-- Code 09PhysicsDebugDraw = class()function PhysicsDebugDraw:init()    -- Create bodies and contacts tables    -- bodies holds object part locations    -- contacts hols start/end points of a contact    self.bodies = {}    self.contacts = {}endfunction PhysicsDebugDraw:addBody(body)        table.insert(self.bodies,body)endfunction PhysicsDebugDraw:draw()        pushStyle()    smooth()        strokeWidth(5)    stroke(255,255,255,255)    noFill()        -- Iterate through bodies and creates lines and circle    -- needed to draw the objects    for i,body in ipairs(self.bodies) do        -- pushMatrix saves the environment so our        -- changes are localized        pushMatrix()        translate(body.x, body.y)        rotate(body.angle)            -- Determine object type and set stroke color        -- gound is white, car is green        if body.type == STATIC then            stroke(255,255,255,255)        elseif body.type == DYNAMIC then            stroke(150,255,150,255)        elseif body.type == KINEMATIC then            stroke(150,150,255,255)        end            -- Use bodies data to draw visible lines        if body.shapeType == POLYGON then            strokeWidth(3.0)            local points = body.points            for j = 1,#points do                a = points[j]                b = points[(j % #points)+1]                line(a.x, a.y, b.x, b.y)            end        elseif body.shapeType == CIRCLE then            strokeWidth(3.0)            line(0,0,body.radius-3,0)                        ellipse(0,0,body.radius*2)        end        -- restore previous environment        popMatrix()    end         -- Get ready to draw contact points    stroke(255, 0, 0, 255)    fill(255, 0, 0, 255)        -- Turn contact points on or off    if DrawContacts then        for k,v in pairs(self.contacts) do            for m,n in ipairs(v.points) do                ellipse(n.x, n.y, 10, 10)            end        end    end        popStyle()endfunction PhysicsDebugDraw:collide(contact)    -- When objects collide (touch) take action    if contact.state == BEGAN then        -- Sound alarm mark contacts in contacts table        self.contacts[contact.id] = contact        sound(SOUND_HIT, 2643)    elseif contact.state == MOVING then        self.contacts[contact.id] = contact    -- When contact ends mark contacts table entry as nil    elseif contact.state == ENDED then        self.contacts[contact.id] = nil    endend--# Car-- Code 09 Car = class()function Car:setup()        -- Create a gound object and assign it to ground    local ground = createGround()    -- Set friction, change this value and see how movement of    -- the car changes    ground.friction = 1    -- Below two car objects are defined. The first is the default    -- The second was created to play with drawing an object--    local car = physics.body(POLYGON, vec2(-50,10), vec2(-50,-10), vec2(50,-10), vec2(50,10), --                                        vec2(30,10), vec2(25,25), vec2(-25,25), vec2(-30,10))                                                local car = physics.body(POLYGON, vec2(-50,10), vec2(-50,-10), vec2(50,-10), vec2(50,10),                                          vec2(30,10), vec2(30,20), vec2(-30,20), vec2(-30,10))       -- Set car first position then add car to bodies table    car.position = vec2(WIDTH/2, 50)    debugDraw:addBody(car)    -- Set car density change this to see the effects    car.density = 2        -- I don't know this and it mat not be required    local piston = physics        -- Create left wheel    local leftPos = vec2(WIDTH/2 - 30, 40)    local leftWheel = createCircle(leftPos.x, leftPos.y, 20)     leftWheel.friction = 1    -- REVOLUTE means it can rotate    self.leftJoint = physics.joint(REVOLUTE, car, leftWheel, leftWheel.position)        -- Only the left wheel has a motor    self.leftJoint.maxMotorTorque = 100        -- Create right wheel    local rightPos = vec2(WIDTH/2 + 30, 40)    local rightWheel = createCircle(rightPos.x, rightPos.y, 15)        rightWheel.friction = 1    self.rightJoint = physics.joint(REVOLUTE, car, rightWheel, rightWheel.position)        -- Create the four small boxes    -- Loop starts at 25, increments by 20, and ends when y >= 85    for y = 25,85,20 do        createBox(WIDTH/2 + 150, y, 20,20)    end    endfunction createCircle(x,y,r)    -- Function to create a circle using x, y, and r    local circle = physics.body(CIRCLE, r)    -- enable smooth motion    circle.interpolate = true    circle.x = x    circle.y = y    -- restitution is bounce amount    circle.restitution = 0.25    circle.sleepingAllowed = false    -- Add to bodies table    debugDraw:addBody(circle)    return circleendfunction createBox(x,y,w,h)    -- polygons are defined by a series of points in counter-clockwise order    local box = physics.body(POLYGON, vec2(-w/2,h/2), vec2(-w/2,-h/2),                                     vec2(w/2,-h/2), vec2(w/2,h/2))    box.interpolate = true    box.x = x    box.y = y    box.restitutions = 0.25    box.sleepingAllowed = false    -- Add to bodies table    debugDraw:addBody(box)    return boxendfunction createGround()    -- Create gound    local ground = physics.body(POLYGON, vec2(0,20), vec2(0,0), vec2(WIDTH,0), vec2(WIDTH,20))    ground.type = STATIC    -- Add to bodies table    debugDraw:addBody(ground)    return groundendfunction Car:touched(touch)    -- If screen was touched determine if touch was left or right     -- side of the screen    if touch.state == BEGAN or touch.state == MOVING then        -- Turns on motor         self.leftJoint.enableMotor = true                -- Set motor speed and forward or reverse        if touch.x > WIDTH/2 then            self.leftJoint.motorSpeed = -1000        else            self.leftJoint.motorSpeed = 1000        end    -- When touch ends set motor speed to zero    -- If you disable motor you get free spin    -- and car may not stop    elseif touch.state == ENDED then        self.leftJoint.motorSpeed = 0       -- self.leftJoint.enableMotor = false    endend